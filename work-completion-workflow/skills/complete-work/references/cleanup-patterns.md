# Cleanup Pattern Detection Reference

Comprehensive guide for the file-cleaner agent on how to detect files for archiving.

## Detection Layers

### Layer 1: Universal Patterns

Patterns that apply to ALL projects regardless of language or framework.

#### Test Artifacts

```yaml
Patterns:
  - "*.test.js.snap"
  - "coverage/"
  - "lcov-report/"
  - ".nyc_output/"
  - ".pytest_cache/"
  - "__pycache__/"
  - "htmlcov/"
  - ".tox/"
  - ".nox/"

Rationale:
  - Generated by test runners
  - Can be regenerated on demand
  - Often large in size
  - No long-term value

Safety:
  - Check if .gitignore already excludes
  - Never archive if modified < 7 days (active testing)
```

#### Build Outputs

```yaml
Patterns:
  - "dist/"
  - "build/"
  - "out/"
  - "*.min.js"
  - "*.min.css"
  - "*.bundle.js"
  - "*.map" (source maps)

Rationale:
  - Compiled from source
  - Reproducible via build command
  - Can be large

Safety:
  - Check package.json/tsconfig.json for build output directory
  - Never archive if build/ is tracked in git (some projects track builds)
```

#### Debug/Log Files

```yaml
Patterns:
  - "*-debug.log"
  - "*.log" (with size > 1MB)
  - "npm-debug.log"
  - "yarn-error.log"
  - "pnpm-debug.log"
  - "firebase-debug.log"
  - "*.tmp"
  - "*.cache"

Rationale:
  - Temporary debugging information
  - Becomes stale quickly
  - Can be large

Safety:
  - Always safe to archive (never tracked in git)
  - Check size before archiving (< 1MB might be intentional)
```

#### Generated Code

```yaml
Patterns:
  - "*-generated.ts"
  - "*_generated.py"
  - "*.g.dart"
  - "*_pb2.py" (Protocol Buffers)
  - "*.pb.go"

Rationale:
  - Auto-generated from schema/IDL
  - Can be regenerated
  - Often large

Safety:
  - Check if there's a generator script (schema.proto → *_pb2.py)
  - Never archive if no generator found
```

### Layer 2: Git-Based Analysis

Use git history to identify stale files.

#### Files Not Modified in 60+ Days

```bash
# Generate list of recently touched files
git log --all --pretty=format: --name-only --since="60 days ago" \
  | sort -u > /tmp/recent_files.txt

# Find all files NOT in that list
find . -type f -not -path "./.git/*" -not -path "./node_modules/*" \
  | grep -v -F -f /tmp/recent_files.txt

# Additional filters
# - Exclude small files (< 100KB) - might be docs
# - Exclude config files (.json, .yml, .md)
# - Focus on code files and assets
```

#### Files with Stale Indicators in Name

```bash
# Find files with "old", "temp", "backup", "deprecated" in name
find . -type f \
  -iregex ".*\(old\|temp\|backup\|deprecated\|bak\|copy\).*" \
  -mtime +60 \
  -not -path "./.git/*" \
  -not -path "./node_modules/*"
```

#### Large Files Not Modified Recently

```bash
# Files > 10MB not modified in 30 days
find . -type f -size +10M -mtime +30 \
  -not -path "./.git/*" \
  -not -path "./node_modules/*" \
  -not -path "./.archive/*"

# Likely candidates:
# - Old database dumps
# - Cached API responses
# - Stale build artifacts
# - Old media files
```

### Layer 3: Project Context Detection

Detect project type and apply language-specific patterns.

#### Node.js Project (has package.json)

```yaml
Detection:
  - file: "package.json"

Patterns:
  - "node_modules/" (report size only, NEVER archive)
  - "dist/" (if scripts.build exists)
  - "build/"
  - ".next/" (Next.js)
  - ".nuxt/" (Nuxt.js)
  - "*.log"
  - ".eslintcache"
  - ".yarn/cache/" (Yarn 2+)

Scripts Analysis:
  # Read package.json scripts to infer patterns
  - scripts.build → check "dist/" or output dir
  - scripts.test → check "coverage/"
  - scripts.start → check for dev artifacts

Safety:
  - Check .gitignore for already-excluded patterns
  - Never archive node_modules (too large, always regenerable)
```

#### Python Project (requirements.txt or pyproject.toml)

```yaml
Detection:
  - file: "requirements.txt" OR "pyproject.toml"

Patterns:
  - "__pycache__/"
  - "*.pyc"
  - "*.pyo"
  - ".pytest_cache/"
  - ".mypy_cache/"
  - ".ruff_cache/"
  - "*.egg-info/"
  - ".venv/" (report only)
  - "venv/" (report only)
  - ".tox/"
  - ".nox/"

Safety:
  - Never archive virtual environments (large, regenerable)
  - Check if .gitignore excludes these
```

#### TypeScript Project (has tsconfig.json)

```yaml
Detection:
  - file: "tsconfig.json"

Patterns:
  - "*.d.ts" (if generated, check tsconfig.outDir)
  - "*.tsbuildinfo"
  - "dist/" or tsconfig.outDir
  - "*.js.map"

Analysis:
  # Read tsconfig.json to determine if .d.ts are generated
  - declaration: true → check outDir for *.d.ts
  - incremental: true → check for *.tsbuildinfo

Safety:
  - Don't archive hand-written .d.ts files (type definitions)
  - Check git history to see if .d.ts are tracked
```

#### Rust Project (has Cargo.toml)

```yaml
Detection:
  - file: "Cargo.toml"

Patterns:
  - "target/" (build directory)
  - "Cargo.lock" (never archive, needed for reproducible builds)

Safety:
  - target/ can be HUGE (GBs)
  - Always archive target/ if > 1GB
  - Never archive Cargo.lock (critical for reproducibility)
```

#### Go Project (has go.mod)

```yaml
Detection:
  - file: "go.mod"

Patterns:
  - "bin/" (if exists)
  - "*.test"
  - "go.sum" (never archive, needed for builds)

Safety:
  - Don't archive go.sum (like Cargo.lock)
  - Check if bin/ is tracked in git
```

#### Firebase Project (has firebase.json)

```yaml
Detection:
  - file: "firebase.json"

Patterns:
  - "firebase-debug.log"
  - ".firebase/cache/"
  - ".firebase/*.cache"

Safety:
  - Keep .firebase/ config files
  - Only archive debug logs and caches
```

### Layer 4: User Preference Learning

Load and apply patterns from `.claude/cleanup-patterns.local.md`.

#### Pattern File Schema

```yaml
---
patterns:
  # Patterns to ALWAYS archive (no prompt)
  archive_always:
    - "firebase-debug.log"
    - "coverage/"
    - "scripts/migration-*.sql"

  # Patterns to NEVER archive
  never_archive:
    - "scripts/setup.sh"
    - ".env*"
    - "*.config.js"

  # Time-based rule
  archive_if_old_days: 180

  # Size-based rule
  archive_if_larger_mb: 50
---
```

#### Application Logic

```python
def should_archive(file_path):
    # Check never_archive first
    for pattern in never_archive:
        if matches_glob(file_path, pattern):
            return False

    # Check archive_always
    for pattern in archive_always:
        if matches_glob(file_path, pattern):
            return True

    # Check time-based rule
    if file_age_days(file_path) > archive_if_old_days:
        return True

    # Check size-based rule
    if file_size_mb(file_path) > archive_if_larger_mb:
        return True

    # Unknown pattern - ask user
    return None  # Trigger learning session
```

## Pattern Learning Flow

### First Run (No Pattern File)

```
1. Run Layers 1-3 detection
2. Categorize findings:
   - Universal (known safe)
   - Project-specific (inferred)
   - Uncertain (ask user)

3. Present to user:
   "Found 15 cleanup candidates:

   Temporary Files (3) - always safe to archive
   Build Artifacts (5) - safe to archive
   Old Scripts (2) - uncertain, need your guidance

   What should I do?
   1. Archive all
   2. Let me teach you patterns
   3. Skip"

4. If user selects #2:
   For each uncertain pattern:
     "Pattern: scripts/migration-*.sql
      Matches: 2 files (old migration scripts)
      Archive this? (y/n/always)"

5. Save "always" selections to pattern file
```

### Subsequent Runs (Pattern File Exists)

```
1. Load patterns from .claude/cleanup-patterns.local.md
2. Run Layers 1-3 detection
3. Apply learned patterns automatically
4. Only ask about NEW patterns not in file

Output:
  "Auto-archiving (learned patterns):
   ✓ firebase-debug.log (matches: firebase-debug.log)
   ✓ coverage/ (matches: coverage/)

   New pattern detected:
   - .next/cache/ (50 MB)
     Archive this? (y/n/always)"
```

## Safety Checks

### Pre-Archive Validation

```bash
# For each file to archive:

# 1. Check for uncommitted changes
git status --short "$file" | grep -q "^[MADRCU]"
# If match → SKIP (uncommitted)

# 2. Check modification time
stat -f %Sm -t %s "$file"
current_time=$(date +%s)
age_days=$(( (current_time - file_mtime) / 86400 ))
# If age < 7 days AND not in universal temp patterns → SKIP

# 3. Check if config file
echo "$file" | grep -qE "\.(env|config\.(js|json|yaml|yml)|rc)$"
# If match → SKIP

# 4. Check if in never_archive list
grep -qF "$file" .claude/cleanup-patterns.local.md
# If in never_archive → SKIP

# 5. Check if currently open in editor (if detectable)
lsof "$file" 2>/dev/null | grep -q EDITOR
# If locked → SKIP with warning
```

### Special Cases

#### node_modules/

```yaml
Action: NEVER archive
Instead:
  - Report size
  - Suggest: "npm ci to reinstall if needed"
  - Note in commit message if exceptionally large
```

#### .git/

```yaml
Action: NEVER touch
Safety: Hard-coded exclusion
```

#### Hidden Files (.*)

```yaml
Action: Only if explicitly matched
Examples:
  - .eslintcache → SAFE (universal pattern)
  - .next/cache/ → SAFE (Next.js pattern)
  - .myconfig → ASK (unknown dotfile)
```

## Archive Organization

### Directory Structure

```
.archive/
└── YYYY-MM-DD-HH-MM/
    ├── MANIFEST.md
    ├── temp-files/
    │   ├── firebase-debug.log
    │   └── *.tmp
    ├── old-scripts/
    │   └── migration-*.sql
    ├── build-artifacts/
    │   └── dist/
    └── test-coverage/
        └── coverage/
```

### Categorization Logic

```python
categories = {
    'temp-files': ['*.log', '*.tmp', '*.cache'],
    'test-coverage': ['coverage/', '.nyc_output/', '__pycache__/'],
    'build-artifacts': ['dist/', 'build/', 'out/', '*.min.js'],
    'old-scripts': ['scripts/*-old-*', 'scripts/migration-*'],
    'large-files': lambda f: file_size_mb(f) > 50,
    'uncategorized': default
}

def categorize(file_path):
    for category, patterns in categories.items():
        if callable(patterns):
            if patterns(file_path):
                return category
        else:
            for pattern in patterns:
                if matches(file_path, pattern):
                    return category
    return 'uncategorized'
```

## MANIFEST.md Template

```markdown
# Archive Manifest

**Created**: {timestamp}
**Retention**: 2 years (delete after {retention_date})
**Recovery**: `cp -r .archive/{archive_dir}/* .`

---

## Archived Files

{for each category}
### {Category Name} ({file_count} files, {total_size})

{for each file}
- `{file_path}` ({size})
  - **Pattern**: {matched_pattern} (learned {date} OR universal)
  - **Reason**: {reason}
  - **Modified**: {last_modified}
  - **Age**: {age_days} days
{end for}
{end for}

---

## Patterns Applied

### Learned Patterns ({count})
{list learned patterns with dates}

### Universal Patterns ({count})
{list universal patterns}

---

## Recovery Instructions

[Recovery commands and instructions]

---

## Retention Policy

This archive will be automatically deleted after **{retention_date}** (2 years).
```

## Performance Optimization

### Parallel Detection

```bash
# Run layers in parallel
(
  run_layer1 &
  run_layer2 &
  run_layer3 &
  wait
) > /tmp/all_candidates.txt

# Deduplicate and merge
sort -u /tmp/all_candidates.txt
```

### Caching

```yaml
Cache:
  - Git file list (60 seconds TTL)
  - Project type detection (session-scoped)
  - Pattern file parse (until modified)

Invalidation:
  - On git operations (commit, checkout)
  - On pattern file modification
```

## Error Handling

### Locked Files

```markdown
⚠️ Could not archive: {file_path} (currently in use)

Recommendation: Close editors and retry, or manually archive later.
```

### Permission Denied

```markdown
❌ Cannot move {file_path} to archive (permission denied)

Check file permissions and ownership.
```

### Disk Space

```markdown
⚠️ Insufficient disk space for archive creation

Required: {required_mb} MB
Available: {available_mb} MB

Reduce cleanup scope or free up disk space.
```

## Testing Checklist

- [ ] Universal patterns detect common temp files
- [ ] Git analysis finds truly old files (not recent)
- [ ] Project detection works for all supported types
- [ ] Pattern learning saves "always" choices correctly
- [ ] Auto-apply works on subsequent runs
- [ ] Safety checks prevent archiving uncommitted changes
- [ ] MANIFEST.md is comprehensive and accurate
- [ ] Archive structure is organized by category
- [ ] Retention policy is set to 2 years
- [ ] Recovery instructions work correctly
